# Mutating data

Often the data you have will prompt questions that it doesn't immediately answer. Election results, for example, have raw vote totals but we often don't use those to make comparisons between candidates unless the numbers are small. We need percentages!

To do that in R, we can use `dplyr` and `mutate` to calculate new metrics in a new field using existing fields of data. That's the essence of `mutate` - using the data you have to answer a new question.

So first we'll import the tidyverse so we can read in our data and begin to work with it.

```{r}
#| output: false
library(tidyverse)
```

Now we'll import a dataset of county-level gubernatorial results from Maryland's 2022 general election that is in the data folder in this chapter's pre-lab directory. We'll use this to explore ways to create new information from existing data.

```{r}
general_22 <- read_csv('data/md_gov_county.csv')
```

Let's add a column called `percent_moore` for the percentage of votes that went to Wes Moore, the Democratic candidate who won the election, in each county. The code to calculate a percentage is pretty simple. Remember, with `summarize`, we used `n()` to count things. With `mutate`, we use very similar syntax to calculate a new value -- a new column of data -- using other values in our dataset.

To calculate a percentage, we need both the number of votes for Moore but also the total number of votes. We'll use mutate to create both columns. The first will be total votes. The key here is to save the dataframe to itself so that our changes stick.

```{r}
general_22 <- general_22 %>%
  mutate(
    total_votes = cox + moore + lashar + wallace + write_ins,
    pct_moore = moore/total_votes
  )
```

But what do you see right away? Do those numbers look like we expect them to? No. They're a decimal expressed as a percentage. So let's fix that by multiplying by 100. Since we're replacing the contents of our new `pct_moore` column, we can just update our previous code and run it again:

```{r}
general_22 <- general_22 %>%
  mutate(
    pct_moore = (moore/total_votes)*100
  )
```

Now, does this ordering do anything for us? No. Let's fix that with arrange.

```{r}
general_22 <- general_22 %>%
  mutate(
    pct_moore = (moore/total_votes)*100
  ) %>% 
  arrange(desc(pct_moore))
```

So now we have results ordered by `pct_moore` with the highest percentage first. To see the lowest percentage first, we can reverse that `arrange` function - we don't need to recalculate the column:

```{r}
general_22 %>%
  arrange(pct_moore)
```

Moore had his weakest performance in Garrett County, at the far western edge of the state.

## Another use of mutate

Mutate is also useful for standardizing data - for example, making different spellings of, say, campaign spending recipients.

Let's take a look at that `maryland_expenses` dataframe, and in particular the `payee_name` column.

```{r}
maryland_expenses
```

You'll notice that there's a mix of styles: lower-case and upper-case names like "Anedot" and "ANEDOT", for example. R will think those are two different payees, and that will mean that any aggregates we create based on payee_name won't be accurate.

So how can we fix that? Mutate - it's not just for math! And a function called `str_to_upper` that will convert a character column into all uppercase.

```{r}
standardized_maryland_expenses <- maryland_expenses %>%
  mutate(
    payee_upper = str_to_upper(payee_name)
)
```

There are lots of potential uses for standardization - addresses, zip codes, anything that can be misspelled or abbreviated.

## A more powerful use

Mutate is even more useful when combined with some additional functions. Let's wind up where we started: with our UMD course data. We have those values for terms, but it's not clear what semesters they actually refer to. We'd like to have columns for year and semester based on the values we have for `term`. Let's look at those unique values using a function called `distinct`:

```{r}
umd_courses %>% distinct(term)
```

We can see that each term value begins with a year and ends with two digits: "01", "05", "08" and "12". We can turn those into semester equivalents by looking them up: "01" indicates Spring semesters, like [the current one](https://app.testudo.umd.edu/soc/search?courseId=&sectionId=&termId=202301).

Mutate can make that happen by creating a new column and putting in a value *based on the term value* of each record. We can use the `case_when` function to give our new columns a value using some standard logic:

```{r}
umd_courses_terms <- umd_courses %>%
  mutate(
    term_name = case_when(
        term == 202305 ~ "Summer",
        term == 202301 ~ "Spring",
        term == 202212 ~ "Winter",
        term == 202208 ~ "Fall",
        term == 202205 ~ "Summer",
        term == 202201 ~ "Spring",
        term == 202112 ~ "Winter",
        term == 202108 ~ "Fall",
        term == 202105 ~ "Summer",
        term == 202101 ~ "Spring",
        term == 202012 ~ "Winter",
        term == 202008 ~ "Fall",
        term == 202005 ~ "Summer",
        term == 202001 ~ "Spring",
        term == 201912 ~ "Winter",
        term == 201908 ~ "Fall",
        term == 201905 ~ "Summer",
        term == 201901 ~ "Spring",
        term == 201812 ~ "Winter",
        term == 201808 ~ "Fall",
        term == 201805 ~ "Summer",
        term == 201801 ~ "Spring",
        term == 201712 ~ "Winter",
      )
  )
```

We can then use our new `term_name` column in group_by statements to make summarizing easier:

```{r}
umd_courses_terms %>%
  group_by(term_name) %>%
  summarize(count_classes = n()) %>%
  arrange(desc(count_classes))
```

More courses in the fall, which makes sense, although the difference between the Fall and Spring semesters isn't huge.

Mutate is there to make your data more useful and to make it easier for you to ask more and better questions of it.
